<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Story of Optics — Geometry, Light, and Scale</title>
    
    <!-- MathJax for rendering equations -->
    <script>
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']],
        processEscapes: true
      },
      svg: {
        fontCache: 'global'
      }
    };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <style>
        :root {
            --primary: #1a237e; /* Navy */
            --secondary: #006064; /* Cyan */
            --accent: #ff6f00;  /* Amber */
            --paper: #fdfbf7;   /* Warm Paper Background */
            --text: #263238;    /* Dark Blue Grey */
            --code-bg: #263238;
            --panel-bg: #eceff1;
        }

        body {
            font-family: 'Merriweather', 'Georgia', serif;
            background-color: var(--paper);
            color: var(--text);
            margin: 0;
            padding: 0;
            line-height: 1.8;
        }

        h1, h2, h3, h4 {
            font-family: 'Segoe UI', 'Roboto', sans-serif;
            color: var(--primary);
            margin-top: 1.8em;
            font-weight: 700;
        }

        p.narrative {
            font-size: 1.15rem;
            color: #37474f;
            margin-bottom: 1.5em;
            max-width: 800px;
        }

        .highlight-box {
            background-color: #e3f2fd;
            border-left: 5px solid var(--primary);
            padding: 20px 30px;
            margin: 30px 0;
            font-family: 'Segoe UI', sans-serif;
            font-style: italic;
            color: #0d47a1;
        }

        .advanced-read {
            border-left: 4px solid #ff6f00;
            background: #fff8e1;
            padding: 25px;
            margin: 25px 0;
            font-size: 1.05rem;
            border-radius: 0 4px 4px 0;
        }

        .hero {
            background: linear-gradient(135deg, #0d47a1 0%, #1565c0 100%);
            color: white;
            padding: 100px 20px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            margin-bottom: 50px;
        }

        .hero h1 { color: white; margin: 0; font-size: 3rem; letter-spacing: -1px; }
        .hero p { font-size: 1.3rem; opacity: 0.9; font-style: italic; margin-top: 15px; font-family: 'Segoe UI', sans-serif;}

        .container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
        }

        section {
            background: white;
            padding: 50px;
            margin-bottom: 50px;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.06);
            border-top: 4px solid var(--primary);
        }

        .lab-wrapper {
            border: 1px solid #cfd8dc;
            background: #fff;
            border-radius: 8px;
            overflow: hidden;
            margin: 40px 0;
            box-shadow: 0 8px 20px rgba(0,0,0,0.08);
        }

        canvas {
            display: block;
            width: 100%;
            height: 420px;
            cursor: crosshair;
            background: radial-gradient(circle at 50% 50%, #ffffff 0%, #f5f5f5 100%);
        }

        #pinhole-canvas { background: linear-gradient(90deg, #f5f5f5 50%, #263238 50%); }
        #obscura-canvas { background: linear-gradient(90deg, #f1f8e9 50%, #263238 50%); }

        .controls-bar {
            background: var(--panel-bg);
            padding: 25px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            border-top: 1px solid #b0bec5;
            font-family: 'Segoe UI', sans-serif;
            font-size: 0.95rem;
        }

        .slider-group { display: flex; flex-direction: column; }
        .slider-group label { 
            display: flex; justify-content: space-between; 
            font-weight: 600; color: var(--secondary); margin-bottom: 8px; 
        }
        
        input[type=range] { width: 100%; cursor: pointer; accent-color: var(--primary); }

        .btn-toggle {
            background: white;
            border: 2px solid var(--primary);
            color: var(--primary);
            padding: 8px 16px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
            margin-right: 10px;
            margin-bottom: 10px;
        }
        .btn-toggle:hover { background: #e8eaf6; }
        .btn-toggle.active { background: var(--primary); color: white; }

        .stats-panel {
            font-family: 'Courier New', monospace;
            background: var(--code-bg);
            color: #b2dfdb;
            padding: 20px;
            font-size: 0.9rem;
            display: grid;
            grid-template-columns: 1fr 1fr;
            border-top: 1px solid #37474f;
        }

        #graph-canvas { height: 280px; background: #fff; border-top: 1px solid #eee; }

        @media (max-width: 768px) {
            .hero h1 { font-size: 2.2rem; }
            section { padding: 25px; }
            canvas { height: 300px; }
            .stats-panel { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>

<div class="hero">
    <h1>The Story of Optics</h1>
    <p>Physics is the art of turning simple geometry into instruments that see the universe.</p>
</div>

<div class="container">

    <!-- INTRO -->
    <section>
        <h2>From Shape to Light</h2>
        <p class="narrative">
            Every measurement in physics is made by comparing two things. A length is measured by comparing it with a ruler; a time is measured by comparing a motion with a clock. But there is something even more primitive than length and time: <strong>shape</strong>.
        </p>
        <p class="narrative">
            When we look at an object far away, it looks smaller, yet we recognize it as the same object. That recognition is not about size—it is about shape. Physics, in its deepest operational form, deals not with absolute size but with how shapes change under scaling.
        </p>
        <div class="highlight-box">
            "Optics is geometry scaled by light."
        </div>
        <p class="narrative">
            In geometrical optics, light rays travel in straight lines until they meet a mirror or a lens. When rays from the top and bottom of an object meet after reflection, they form triangles. These triangles always have the same angles. Therefore, they must be <strong>Similar Triangles</strong>.
        </p>
    </section>

    <!-- CHAPTER 1: PINHOLE (ABSTRACT) -->
    <section>
        <h2>Chapter 1: The Pinhole (Pure Geometry)</h2>
        <p class="narrative">
            Before we look at the complex world of lenses, let us look at the simplest optical instrument: the Pinhole.
        </p>
        <p class="narrative">
            Here, we represent the object as a simple Arrow. Notice the geometry. The light travels in straight lines through the hole, forming two triangles joined at the tip. The ratio of heights exactly equals the ratio of distances.
        </p>

        <div class="lab-wrapper">
            <canvas id="pinhole-canvas"></canvas>
            <div class="controls-bar">
                <div class="slider-group">
                    <label>Object Distance ($u$): <span id="p-u-val"></span></label>
                    <input type="range" id="p-u-input" min="-400" max="-50" value="-200">
                </div>
                <div class="slider-group">
                    <label>Box Depth ($v$): <span id="p-v-val"></span></label>
                    <input type="range" id="p-v-input" min="50" max="300" value="150">
                </div>
            </div>
            <div class="stats-panel">
                <div id="p-calc-res"></div>
                <div style="text-align: right; opacity: 0.7;">$m = v / u$</div>
            </div>
        </div>

        <p class="narrative">
            From this alone comes the magnification formula:
            $$ \frac{\text{image height}}{\text{object height}} = \frac{\text{image distance}}{\text{object distance}} $$
        </p>
    </section>

    <!-- CHAPTER 2: CAMERA OBSCURA (REALISTIC RAY MODEL) -->
    <section>
        <h2>Chapter 2: The Camera Obscura</h2>
        <div class="advanced-read">
            <h3>Apertures & The World Upside Down</h3>
            <p>
                It has been known since ancient times that light passing through a small hole in an opaque barrier casts a dim but full-color image of the outside world onto a wall. This is the <strong>Camera Obscura</strong> (Latin for “dark room”).
            </p>
            <p>
                But there is one problem with viewing the image: <strong>It’s upside down!</strong>
            </p>
            <p>
                The simulation below shows a realistic <strong>Ashoka Tree</strong> (<i>Polyalthia longifolia</i>) outside a dark room.
            </p>
            <p>
                <strong>Trace the Rays:</strong>
                <ul>
                    <li>The <strong style="color:#d32f2f;">RED Ray</strong> originates from the <strong>Top</strong> of the tree. Because light travels in a straight line, it must travel <em>downwards</em> to pass through the tiny hole. It hits the <strong>Bottom</strong> of the back wall.</li>
                    <li>The <strong style="color:#1976d2;">BLUE Ray</strong> originates from the <strong>Bottom</strong> (roots) of the tree. It must travel <em>upwards</em> to pass through the hole. It hits the <strong>Top</strong> of the back wall.</li>
                </ul>
                The aperture acts as a pivot, crossing the rays and creating an <strong>Inverted Image</strong>.
            </p>
        </div>

        <div class="lab-wrapper">
            <canvas id="obscura-canvas"></canvas>
            <div class="controls-bar">
                <div class="slider-group">
                    <label>Tree Distance ($d_o$): <span id="o-d1-val"></span></label>
                    <input type="range" id="o-d1-input" min="50" max="250" value="120">
                </div>
                <div class="slider-group">
                    <label>Room Depth ($d_i$): <span id="o-d2-val"></span></label>
                    <input type="range" id="o-d2-input" min="50" max="300" value="150">
                </div>
            </div>
            <div class="stats-panel">
                <div id="o-calc-res"></div>
                <div style="text-align: right; opacity: 0.7;">Visualization: Ashoka Tree</div>
            </div>
        </div>
    </section>

    <!-- CHAPTER 3: REFLECTION -->
    <section>
        <h2>Chapter 3: Reflection & The Geometric Proof</h2>
        <p class="narrative">
            Pinholes are dim. To gather more light, we use mirrors. But even with curved surfaces, the geometry of similar triangles remains the law of the land.
        </p>
        <div class="lab-wrapper">
            <canvas id="mirror-canvas"></canvas>
            
            <div class="controls-bar">
                <div class="slider-group">
                    <label>Object Distance ($u$): <span id="m-u-val"></span></label>
                    <input type="range" id="m-u-input" min="-400" max="-10" value="-200">
                </div>
                <div class="slider-group">
                    <label>Focal Length ($f$): <span id="m-f-val"></span></label>
                    <input type="range" id="m-f-input" min="-150" max="-40" value="-80">
                    <small>Negative = Concave</small>
                </div>
                
                <div style="display: flex; flex-wrap: wrap;">
                    <button class="btn-toggle" id="btn-tri-pole" onclick="mirrorLab.toggleTriangles('pole')">Show Pole $\triangle$</button>
                    <button class="btn-toggle" id="btn-tri-center" onclick="mirrorLab.toggleTriangles('center')">Show Center $\triangle$</button>
                </div>
            </div>
            <div class="stats-panel">
                <div id="m-calc-res"></div>
                <div id="m-calc-props"></div>
            </div>
        </div>
        
        <div class="highlight-box">
            <strong>The Logic:</strong><br>
            1. From Pole Triangles: $\frac{h_i}{h_o} = \frac{v}{u}$<br>
            2. From Center Triangles: $\frac{h_i}{h_o} = \frac{v - 2f}{2f - u}$<br>
            Combining these leads inevitably to: $\frac{1}{v} + \frac{1}{u} = \frac{1}{f}$
        </div>
    </section>

    <!-- CHAPTER 4: LINEARITY -->
    <section>
        <h2>Chapter 4: The Linearity of Light</h2>
        <p class="narrative">
            The algebra is nothing more than bookkeeping of how scale factors combine. If we plot the "Optical Power" of the image ($1/v$) against the object ($1/u$), we find a straight line.
        </p>
        <div class="lab-wrapper">
             <canvas id="graph-canvas"></canvas>
        </div>
    </section>

    <!-- CHAPTER 5: THE REAL CAMERA (RESTORED TEXT) -->
    <section>
        <h2>Chapter 5: The Real Camera (Lens)</h2>
        <p class="narrative">
            We have seen the Pinhole (geometry) and the Simple Lens (focus). Now, let us look deeper into the physics of the camera itself.
        </p>

        <div class="advanced-read">
            <h3>The Mechanics of Capture</h3>
            <p>
                The camera is a box with a lens in one side of it and a photographic film or a CCD on the opposite side. The distance between camera lens and film can be changed so as to focus on objects at various distances. The <strong>aperture</strong> can also be changed.
            </p>
            <p>
                In dim light you need to open the aperture up to let a lot of light in; but this makes the image less sharp, and you have a smaller depth of field. The aperture of a lens is merely its diameter, and it is usually expressed as a fraction of the focal length. Thus an aperture of $f/22$ is a small aperture. You can use this only in strong light, but you will then have nice sharp images and a large depth of field. An aperture of $f/6.3$ is wide open; the cone of light inside the camera is quite steep, and focussing is then quite critical. You use such a wide aperture only if you are forced to by dim light.
            </p>
            <p>
                The apertures typically available on a camera are often in steps with a ratio of approximately $\sqrt{2}$ from one to the next. As you increase the aperture by a factor of $\sqrt{2}$, you get twice as much light on the film (because this depends on the area of the exposed lens), so presumably you can cut the exposure time by one half.
            </p>

            <h3>Depth of Focus: A Triangle Problem</h3>
            <p>
                How is the depth of focus related to the aperture? Let us suppose that we have a lens that is free of aberrations such as spherical aberration, and that a point object produces a point image in the focal plane. If your film or CCD is not exactly in the plane, it will be illuminated not by a point image but by a small circle of finite diameter. If this circle is smaller than the grain or pixel size, you may wish to regard it as not seriously out of focus.
            </p>
            <p>
                So the question is: How far can you move the film away from the focal plane in either direction without the image being seriously out of focus? This range is the <strong>depth of focus</strong>.
            </p>
            <p>
                Imagine a cone of light converging from a lens of radius $R$ to a focal point at distance $q$. Let us suppose that we place a film or CCD at a distance $x$ from the focal point, and that we are prepared to tolerate an out-of-focus “image” of radius $r$. From similar triangles we see that $x/r = q/R$. Or, if $D$ is the diameter of the lens, and $d$ is the diameter of the tolerable out-of-focus circle, $x/d = q/D$. Thus we can place the film at a distance:
                $$ x = q \frac{d}{D} $$
                on either side of the true focal plane without appreciable degradation of the image. For example, if the aperture is $f/6.3$ (meaning $q/D \approx 6.3$), and you are prepared to tolerate an out-of-focus diameter $d = 0.1 \text{ mm}$, the depth of focus will be $\pm 6.3 \times 0.1 = \pm 0.63 \text{ mm}$. On the other hand if you “stop down” to $f/22$, your depth of focus will be $2.2 \text{ mm}$.
            </p>
            
            <h3>Small Angles & Realism</h3>
            <p>
                Notice that the tangent of the semi angle of the converging cone is $R/q$ or $D/2q$. For apertures of $f/6.3$ and $f/22$, the semi angles are $4.5^\circ$ and $2.6^\circ$ respectively. This may give some comfort to those readers who have been uncomfortable with our assumption that angles are small.
            </p>

            <h3>Depth of Field vs Depth of Focus</h3>
            <p>
                Depth of focus is not the same thing as depth of field. Suppose we want to photograph an object at a distance $p$ from the camera lens, and that we are prepared to tolerate an out-of-focus “image” of diameter up to $d$. Any object at a distance within the range $\Delta p$ may satisfy this.
            </p>
            <p>
                We have essentially two sets of similar triangles to compare: one outside the camera (object space) and one inside (image space). Since $m = v/u$ (or $q/p$), a small shift in the image plane corresponds to a much larger shift in the object plane ($\Delta p \approx \Delta q / m^2$), meaning Depth of Field is typically much larger than Depth of Focus.
            </p>
        </div>

        <div class="lab-wrapper">
            <canvas id="lens-canvas"></canvas>
            <div class="controls-bar">
                <div class="slider-group">
                    <label>Object Distance ($u$): <span id="l-u-val"></span></label>
                    <input type="range" id="l-u-input" min="-400" max="-10" value="-250">
                </div>
                <div class="slider-group">
                    <label>Focal Length ($f$): <span id="l-f-val"></span></label>
                    <input type="range" id="l-f-input" min="-150" max="150" value="100">
                    <small>Pos=Convex, Neg=Concave</small>
                </div>
            </div>
             <div class="stats-panel">
                <div id="l-calc-res"></div>
                <div id="l-calc-props"></div>
            </div>
        </div>
    </section>

    <!-- CHAPTER 6: APPLICATIONS (EYE) -->
    <section>
        <h2>Chapter 6: Scaling Reality (The Eye)</h2>
        <p class="narrative">
            In the human eye, the distance to the "screen" (retina) is fixed. To see objects at different distances, the eye must change its shape (Accommodation).
        </p>
        <div class="lab-wrapper">
            <canvas id="eye-canvas"></canvas>
            <div class="controls-bar">
                <div class="slider-group">
                    <label>Object Approach ($u$):</label>
                    <input type="range" id="eye-u-input" min="-400" max="-50" value="-300">
                </div>
                <div class="slider-group">
                    <label style="color: var(--accent);">Eye Power (Adjust $f$ to Focus!): <span id="eye-f-val"></span></label>
                    <input type="range" id="eye-f-input" min="40" max="120" value="90">
                </div>
            </div>
            <div class="stats-panel" style="text-align: center; display: block;">
                <span id="eye-status" style="font-weight: bold; font-size: 1.1rem;">Status: Blurred</span>
            </div>
        </div>
    </section>

    <!-- CHAPTER 7: TELESCOPE -->
    <section>
        <h2>Chapter 7: The Telescope (Angular Geometry)</h2>
        <p class="narrative">
            A telescope works by <strong>Angular Magnification</strong>. It uses an Objective lens to create an image, and an Eyepiece to magnify it.
        </p>
        <div class="lab-wrapper">
            <canvas id="telescope-canvas"></canvas>
            <div class="controls-bar">
                <div class="slider-group">
                    <label>Objective Focal Length ($f_o$): <span id="t-fo-val"></span></label>
                    <input type="range" id="t-fo-input" min="150" max="300" value="200">
                </div>
                <div class="slider-group">
                    <label>Eyepiece Focal Length ($f_e$): <span id="t-fe-val"></span></label>
                    <input type="range" id="t-fe-input" min="20" max="100" value="50">
                </div>
            </div>
            <div class="stats-panel">
                <div id="t-calc-res"></div>
                <div>Condition: Normal Adjustment ($L = f_o + f_e$)</div>
            </div>
        </div>
    </section>

    <!-- SUMMARY -->
    <section>
        <h2>Summary: The Mathematics of Copying</h2>
        <p class="narrative">
            We have seen that $m = v/u$ is not just a formula. It is the statement that the shape of light is preserved.
        </p>
        <p class="narrative">
            The same idea appears in mechanics. When a projectile is thrown, its path at different times is a scaled copy of its earlier path. If time is doubled, distance does not double but grows like $t^2$, which is again a statement about how shapes rescale.
        </p>
        <p class="narrative">
            In waves, a small segment of a wave is similar to a large one. That is why a sinusoid keeps its form whether it is one meter long or a kilometer long. Fourier analysis is nothing but the study of how shapes reproduce themselves at different scales.
        </p>
        <p class="narrative">
            Even in quantum mechanics, the Schrödinger equation preserves shape under scaling of length and energy; bound-state wavefunctions are families of similar curves differing only by scale parameters. Renormalization in field theory is nothing but the statement that physics should look the same when lengths are rescaled, just as a triangle keeps its shape when magnified.
        </p>
        <p class="narrative">
            This is why Socrates could say that geometry is already known. A child knows that a shadow is the same object made larger. Physics is the art of turning that simple truth into instruments that see galaxies and atoms.
        </p>
    </section>

</div>

<script>
/**
 * 2. HD CANVAS SUPPORT
 * Utility to handle Retina/High-DPI displays for crisp rendering and fit.
 */
function setupCanvas(canvas) {
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    
    // Set actual size in memory (scaled to account for extra pixel density)
    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    
    // Normalize coordinate system to use css pixels
    const ctx = canvas.getContext('2d');
    ctx.scale(dpr, dpr);
    
    return ctx;
}

/**
 * THE OPTICS ENGINE
 * Handles ray tracing, geometric logic, and rendering.
 */
class OpticsSystem {
    constructor(canvasId, type) {
        this.canvas = document.getElementById(canvasId);
        // Use the HD setup
        this.ctx = setupCanvas(this.canvas);
        
        this.type = type; // 'mirror', 'lens', 'eye', 'pinhole'
        
        // Physics State
        this.u = -200;
        this.f = type === 'mirror' ? -80 : 100;
        this.v = 0; 
        this.m = 0;
        this.h_o = 50; // Object height
        this.h_i = 0;
        
        // Visualization State
        this.showPoleTriangles = false;
        this.showCenterTriangles = false;
        
        // Canvas Setup (Logical coordinates)
        this.width = this.canvas.getBoundingClientRect().width;
        this.height = this.canvas.getBoundingClientRect().height;
        
        this.ox = this.width * 0.5;
        this.oy = this.height / 2;
        if (type !== 'pinhole') this.ox = this.width * 0.6; // Shift origin for lens/mirror

        this.attachResizeListener();
    }

    attachResizeListener() {
        window.addEventListener('resize', () => {
            // Re-setup canvas for new size
            this.ctx = setupCanvas(this.canvas);
            this.width = this.canvas.getBoundingClientRect().width;
            this.height = this.canvas.getBoundingClientRect().height;
            this.ox = this.type === 'pinhole' ? this.width * 0.5 : this.width * 0.6;
            this.oy = this.height / 2;
            this.draw();
        });
    }

    calculate() {
        if (this.type === 'pinhole') {
            // Pinhole: v is the screen distance (input), not derived from f
            // Magnification m = v / u (magnitude)
            this.m = this.v / Math.abs(this.u);
            this.h_i = this.h_o * this.m;
        } 
        else if (this.type === 'mirror') {
            // 1/v + 1/u = 1/f
            if (this.u === this.f) { this.v = Infinity; this.m = Infinity; }
            else {
                this.v = (this.u * this.f) / (this.u - this.f);
                this.m = -this.v / this.u;
                this.h_i = this.h_o * this.m;
            }
        } else {
            // Lens: 1/v - 1/u = 1/f
            if (this.u === -this.f) { this.v = Infinity; this.m = Infinity; }
            else {
                this.v = (this.u * this.f) / (this.u + this.f);
                this.m = this.v / this.u;
                this.h_i = this.h_o * this.m;
            }
        }
    }

    draw() {
        const ctx = this.ctx;
        const w = this.width;
        const h = this.height;
        
        ctx.clearRect(0, 0, w, h);
        ctx.save();
        ctx.translate(this.ox, this.oy);
        
        // Axis
        ctx.strokeStyle = this.type === 'pinhole' ? '#78909c' : '#cfd8dc';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(-this.ox, 0);
        ctx.lineTo(w - this.ox, 0);
        ctx.stroke();

        if (this.type === 'pinhole') {
            this.drawPinhole(ctx);
        } else {
            this.drawStandardOptics(ctx);
        }

        ctx.restore();
    }

    drawPinhole(ctx) {
        // Draw Wall
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(0, -150); ctx.lineTo(0, -5);
        ctx.moveTo(0, 5); ctx.lineTo(0, 150);
        ctx.stroke();

        // Draw Box Interior
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        ctx.fillRect(0, -150, this.v, 300);
        
        // Draw Screen
        ctx.strokeStyle = '#b0bec5';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(this.v, -150); ctx.lineTo(this.v, 150);
        ctx.stroke();
        ctx.fillStyle = '#cfd8dc';
        ctx.font = "12px sans-serif";
        ctx.fillText("Screen", this.v + 5, -140);

        // Object (Abstract Arrow)
        this.drawArrow(ctx, this.u, -this.h_o, '#4caf50', 'Object'); 

        // Image (Inverted Arrow)
        this.drawArrow(ctx, this.v, this.h_i, '#ffab91', 'Image');

        // Rays
        ctx.lineWidth = 1;
        ctx.strokeStyle = '#ffeb3b'; 
        ctx.globalAlpha = 0.8;
        
        // Top -> Bottom
        ctx.beginPath(); ctx.moveTo(this.u, -this.h_o); ctx.lineTo(this.v, this.h_i); ctx.stroke();
        // Base -> Base
        ctx.beginPath(); ctx.moveTo(this.u, 0); ctx.lineTo(this.v, 0); ctx.stroke();

        // Triangle Hints
        ctx.fillStyle = 'rgba(76, 175, 80, 0.1)';
        ctx.beginPath(); ctx.moveTo(this.u, -this.h_o); ctx.lineTo(this.u, 0); ctx.lineTo(0, 0); ctx.fill();

        ctx.fillStyle = 'rgba(255, 87, 34, 0.1)';
        ctx.beginPath(); ctx.moveTo(this.v, this.h_i); ctx.lineTo(this.v, 0); ctx.lineTo(0, 0); ctx.fill();
        
        ctx.globalAlpha = 1.0;
        ctx.fillStyle = "#333";
        ctx.fillText("Pinhole", -20, 20);
    }

    drawStandardOptics(ctx) {
        this.drawElement(ctx);
        this.drawPoints(ctx);
        
        // Object
        this.drawArrow(ctx, this.u, -this.h_o, '#2e7d32', 'O');

        // Image & Rays
        if (Math.abs(this.v) < 5000 && Math.abs(this.v) > 1) {
            this.drawArrow(ctx, this.v, -this.h_i, '#c62828', 'I');
            this.drawRays(ctx);
            
            if (this.type === 'mirror') {
                if (this.showPoleTriangles) this.drawPoleTriangles(ctx);
                if (this.showCenterTriangles) this.drawCenterTriangles(ctx);
            }
        }
    }

    drawElement(ctx) {
        ctx.lineWidth = 3;
        ctx.strokeStyle = '#37474f';
        ctx.fillStyle = 'rgba(236, 239, 241, 0.5)';
        
        if (this.type === 'mirror') {
            ctx.beginPath();
            const curve = this.f < 0 ? -15 : 15; 
            ctx.moveTo(0, -100);
            ctx.quadraticCurveTo(curve, 0, 0, 100);
            ctx.stroke();
            // Hatching
            ctx.beginPath();
            ctx.strokeStyle = '#b0bec5';
            ctx.lineWidth = 1;
            for(let y=-100; y<=100; y+=10) {
                if(this.f < 0) { ctx.moveTo(0,y); ctx.lineTo(5,y+5); } 
                else { ctx.moveTo(0,y); ctx.lineTo(-5,y+5); }
            }
            ctx.stroke();
        } else {
            // Lens
            ctx.beginPath();
            ctx.ellipse(0, 0, 10, 100, 0, 0, Math.PI*2);
            ctx.fill();
            ctx.stroke();
        }
    }

    drawArrow(ctx, x, h, color, label) {
        ctx.beginPath();
        ctx.lineWidth = 3;
        ctx.strokeStyle = color;
        ctx.moveTo(x, 0);
        ctx.lineTo(x, h);
        ctx.stroke();
        
        ctx.beginPath();
        const dir = h < 0 ? -1 : 1; // if h is neg (up), dir is -1
        ctx.moveTo(x, h);
        ctx.lineTo(x-5, h - dir*8);
        ctx.lineTo(x+5, h - dir*8);
        ctx.closePath();
        ctx.fillStyle = color;
        ctx.fill();

        ctx.font = "bold 14px sans-serif";
        ctx.fillStyle = color; // Fix color being overridden
        ctx.fillText(label, x-10, h - dir*15);
    }

    drawPoints(ctx) {
        ctx.fillStyle = '#455a64';
        const pts = [{x: this.f, t: 'F'}, {x: 2*this.f, t: this.type==='mirror'?'C':'2F'}];
        if(this.type === 'lens') { pts.push({x:-this.f, t:"F'"}, {x:-2*this.f, t:"2F'"}); }
        
        pts.forEach(p => {
            ctx.beginPath(); ctx.arc(p.x, 0, 3, 0, Math.PI*2); ctx.fill();
            ctx.fillText(p.t, p.x-5, 15);
        });
        ctx.fillText(this.type==='mirror'?'P':'O', 2, 15);
    }

    drawRays(ctx) {
        const objHead = {x: this.u, y: -this.h_o};
        const imgHead = {x: this.v, y: -this.h_i}; 

        ctx.lineWidth = 1.5;
        
        // Ray 1: Parallel -> Focus
        this.traceRay(ctx, objHead.x, objHead.y, 0, objHead.y, '#ef6c00'); 
        if(this.type==='mirror') this.traceRay(ctx, 0, objHead.y, imgHead.x, imgHead.y, '#ef6c00'); 
        else this.traceRay(ctx, 0, objHead.y, imgHead.x, imgHead.y, '#ef6c00');

        // Ray 2: Center 
        if (this.type === 'mirror') {
            this.traceRay(ctx, objHead.x, objHead.y, 0, 0, '#0097a7');
            this.traceRay(ctx, 0, 0, imgHead.x, imgHead.y, '#0097a7');
        } else {
            this.traceRay(ctx, objHead.x, objHead.y, imgHead.x, imgHead.y, '#0097a7');
        }
    }

    traceRay(ctx, x1, y1, x2, y2, color) {
        ctx.strokeStyle = color;
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
    }

    // --- TRIANGLE VISUALIZERS ---
    drawPoleTriangles(ctx) {
        this.fillTriangle(ctx, this.u, -this.h_o, 0, 0, this.u, 0, 'rgba(46, 125, 50, 0.2)');
        this.fillTriangle(ctx, this.v, -this.h_i, 0, 0, this.v, 0, 'rgba(46, 125, 50, 0.2)');
    }
    drawCenterTriangles(ctx) {
        const C = 2 * this.f;
        this.fillTriangle(ctx, this.u, -this.h_o, C, 0, this.u, 0, 'rgba(198, 40, 40, 0.2)');
        this.fillTriangle(ctx, this.v, -this.h_i, C, 0, this.v, 0, 'rgba(198, 40, 40, 0.2)');
    }
    fillTriangle(ctx, x1, y1, x2, y2, x3, y3, color) {
        ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.lineTo(x3, y3); ctx.closePath();
        ctx.fillStyle = color; ctx.fill(); ctx.strokeStyle = color.replace('0.2', '0.8'); ctx.stroke();
    }
    toggleTriangles(set) {
        if(set === 'pole') {
            this.showPoleTriangles = !this.showPoleTriangles;
            document.getElementById('btn-tri-pole').classList.toggle('active');
        } else {
            this.showCenterTriangles = !this.showCenterTriangles;
            document.getElementById('btn-tri-center').classList.toggle('active');
        }
        this.draw();
    }
}

/**
 * NEW SYSTEM: REALISTIC CAMERA OBSCURA (ASHOKA TREE)
 * Renders the Real Tree outside and the Inverted Tree inside.
 */
class CameraObscuraSystem {
    constructor(canvasId) {
        this.canvas = document.getElementById(canvasId);
        this.ctx = setupCanvas(this.canvas);
        
        this.d1 = 120; // Object Distance
        this.d2 = 150; // Image Distance (Depth)
        this.h_o = 60; // Tree Height
        
        this.attachResizeListener();
    }
    
    attachResizeListener() {
        window.addEventListener('resize', () => {
            this.ctx = setupCanvas(this.canvas);
            this.draw();
        });
    }
    
    draw() {
        const ctx = this.ctx;
        const w = this.canvas.getBoundingClientRect().width;
        const h = this.canvas.getBoundingClientRect().height;
        const split = w * 0.6; // Split screen for Side View vs Screen View
        
        ctx.clearRect(0,0,w,h);
        
        // --- LEFT SIDE: SIDE VIEW ---
        ctx.save();
        ctx.translate(50, h/2);
        
        // Coordinates: (0,0) is the Pinhole.
        // X axis is the optical axis.
        // Y axis vertical (Positive Down).
        
        // Draw Ground Line outside
        // Tree base is at y = +40 (below axis). 
        const groundY = 40;
        
        // 1. Draw Ashoka Tree (Object) at x = -d1
        const treeX = -this.d1;
        // Tree Top y = groundY - height.
        const treeTopY = groundY - this.h_o;
        
        this.drawAshokaTree(ctx, treeX, groundY, this.h_o, false); // Upright
        
        // Draw Ground Line
        ctx.strokeStyle = '#795548';
        ctx.beginPath(); ctx.moveTo(treeX - 20, groundY); ctx.lineTo(0, groundY); ctx.stroke();
        
        // 2. Aperture Wall
        ctx.fillStyle = '#333';
        ctx.fillRect(0, -60, 4, 120); // Barrier at x=0
        ctx.clearRect(0, -2, 4, 4); // Hole
        
        // 3. Dark Room Box
        ctx.fillStyle = 'rgba(33, 33, 33, 0.1)';
        ctx.fillRect(0, -70, this.d2, 140);
        ctx.strokeStyle = '#424242';
        ctx.strokeRect(0, -70, this.d2, 140);
        
        // 4. Screen at x = d2
        const screenX = this.d2;
        ctx.fillStyle = '#90a4ae';
        ctx.fillRect(screenX, -70, 4, 140);
        ctx.fillStyle = '#37474f';
        ctx.fillText("Screen", screenX-20, -80);
        
        // 5. Inverted Image Geometry
        // Magnification M = d2 / d1
        const M = this.d2 / this.d1;
        const imgH = this.h_o * M;
        
        // Ray Tracing Logic
        // Top Ray: (-d1, treeTopY) -> (0,0) -> (d2, imgTopY)
        // imgTopY = -treeTopY * (d2/d1) = -treeTopY * M
        // treeTopY is neg (e.g. -20). So imgTopY is pos (e.g. +25). -> Projecting "Down".
        const imgTopY = treeTopY * (-M); // y coordinate of tip
        
        // Base Ray: (-d1, groundY) -> (0,0) -> (d2, imgBaseY)
        // imgBaseY = -groundY * M.
        // groundY is pos (e.g. +40). So imgBaseY is neg (e.g. -50). -> Projecting "Up".
        const imgBaseY = groundY * (-M); 
        
        // Draw Inverted Tree at Screen
        // Base is at imgBaseY (Top, Negative Y). Tip is at imgTopY (Bottom, Positive Y).
        // This means the "ground" of the image is on the ceiling!
        this.drawAshokaTree(ctx, screenX, imgBaseY, imgH, true);
        
        // 6. Draw Explicit Rays with "Selection" Effect
        // Faint Blocked Rays from Top
        ctx.strokeStyle = 'rgba(211, 47, 47, 0.1)'; // Faint Red
        ctx.lineWidth = 1;
        for(let dy = -20; dy <= 20; dy+=5) {
            ctx.beginPath(); ctx.moveTo(treeX, treeTopY); ctx.lineTo(0, dy); ctx.stroke();
        }
        
        // THE RED RAY (Top -> Bottom)
        ctx.strokeStyle = '#d32f2f'; // Red
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(treeX, treeTopY); ctx.lineTo(screenX, imgTopY); ctx.stroke();
        // Arrowhead on ray
        this.drawRayArrow(ctx, treeX*0.5, treeTopY + (0-treeTopY)*0.5, Math.atan2(-treeTopY, -treeX));

        // THE BLUE RAY (Bottom -> Top)
        ctx.strokeStyle = '#1976d2'; // Blue
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(treeX, groundY); ctx.lineTo(screenX, imgBaseY); ctx.stroke();
        // Arrowhead on ray
        this.drawRayArrow(ctx, treeX*0.5, groundY + (0-groundY)*0.5, Math.atan2(-groundY, -treeX));
        
        ctx.restore();
        
        // --- RIGHT SIDE: SCREEN VIEW ---
        // Separator
        ctx.strokeStyle = '#ccc';
        ctx.beginPath(); ctx.moveTo(split, 0); ctx.lineTo(split, h); ctx.stroke();
        
        ctx.save();
        ctx.translate(split + (w-split)/2, h/2);
        
        // Draw "View inside the box" (Circular view)
        ctx.fillStyle = '#212121';
        ctx.beginPath(); ctx.arc(0,0, 100, 0, Math.PI*2); ctx.fill();
        
        // Draw Inverted Tree Centered
        // The tree spans from imgBaseY (top/neg) to imgTopY (bottom/pos).
        // We want to center this span on the view (0,0).
        const centerOffset = (imgBaseY + imgTopY) / 2;
        ctx.translate(0, -centerOffset);
        
        this.drawAshokaTree(ctx, 0, imgBaseY, imgH, true);
        
        ctx.shadowBlur = 0;
        ctx.fillStyle = '#fff';
        ctx.font = "14px sans-serif";
        ctx.fillText("View on Wall", -40, 120);
        ctx.font = "12px monospace";
        ctx.fillStyle = '#bbb';
        ctx.fillText(`Scale: ${M.toFixed(1)}x`, -30, 140);
        
        ctx.restore();
    }
    
    drawRayArrow(ctx, x, y, angle) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);
        ctx.beginPath();
        ctx.moveTo(-5, -3); ctx.lineTo(0,0); ctx.lineTo(-5, 3);
        ctx.stroke();
        ctx.restore();
    }
    
    drawAshokaTree(ctx, x, yBase, h, inverted) {
        // Ashoka tree: Tall, narrow, conical.
        // yBase: The Y coordinate where the trunk starts.
        // h: The height of the tree.
        // inverted: If true, the tree grows visually DOWN from yBase to yTip.
        //           If false, the tree grows visually UP from yBase to yTip.
        // Note: In Canvas, +Y is Down. 
        // So Up means yTip < yBase. Down means yTip > yBase.
        
        const yTip = inverted ? yBase + h : yBase - h;
        const width = h * 0.25; 
        
        ctx.save();
        
        // Trunk
        ctx.strokeStyle = '#5d4037';
        ctx.lineWidth = h * 0.08;
        ctx.beginPath();
        ctx.moveTo(x, yBase);
        ctx.lineTo(x, inverted ? yBase + h*0.15 : yBase - h*0.15);
        ctx.stroke();
        
        // Foliage (Deep Green)
        ctx.fillStyle = inverted ? 'rgba(129, 199, 132, 0.9)' : '#2e7d32'; 
        ctx.beginPath();
        ctx.moveTo(x, yTip); // Tip
        
        // Draw undulating sides
        ctx.bezierCurveTo(
            x - width, (yBase+yTip)/2, 
            x - width/2, yBase, 
            x, yBase - (inverted?-h*0.1:h*0.1) // Trunk junction
        );
        ctx.bezierCurveTo(
            x + width/2, yBase,
            x + width, (yBase+yTip)/2,
            x, yTip
        );
        
        ctx.fill();
        ctx.restore();
    }
}

/**
 * GRAPH SYSTEM
 */
class GraphSystem {
    constructor() {
        this.canvas = document.getElementById('graph-canvas');
        this.ctx = setupCanvas(this.canvas);
    }

    draw(u, v, f) {
        const ctx = this.ctx;
        const w = this.canvas.getBoundingClientRect().width;
        const h = this.canvas.getBoundingClientRect().height;
        
        if (!isFinite(v)) return;
        ctx.clearRect(0,0,w,h);
        
        const scale = 3000; 
        const ox = w/2;
        const oy = h/2;
        
        ctx.strokeStyle = '#aaa';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(0, oy); ctx.lineTo(w, oy); 
        ctx.moveTo(ox, 0); ctx.lineTo(ox, h); 
        ctx.stroke();
        
        ctx.font = "12px sans-serif";
        ctx.fillStyle = "#666";
        ctx.fillText("1/u", w-30, oy - 10);
        ctx.fillText("1/v", ox + 10, 20);

        const invF = 1/f;
        ctx.strokeStyle = '#2196f3';
        ctx.lineWidth = 2;
        ctx.beginPath();
        const x_min = (0 - ox)/scale;
        const y_at_min = -x_min + invF;
        const x_max = (w - ox)/scale;
        const y_at_max = -x_max + invF;
        ctx.moveTo(ox + x_min*scale, oy - y_at_min*scale);
        ctx.lineTo(ox + x_max*scale, oy - y_at_max*scale);
        ctx.stroke();

        const curX = 1/u;
        const curY = 1/v;
        ctx.fillStyle = '#ff6f00';
        ctx.beginPath(); ctx.arc(ox + curX*scale, oy - curY*scale, 6, 0, Math.PI*2); ctx.fill();
    }
}

/**
 * EYE SYSTEM (Extension)
 */
class EyeSystem extends OpticsSystem {
    constructor(canvasId) {
        super(canvasId, 'lens');
        this.retinaX = 180;
        this.u = -300;
        this.f = 90;
        this.ox = this.width * 0.4;
    }
    
    // Override resize to maintain Eye specific offsets
    attachResizeListener() {
        window.addEventListener('resize', () => {
            this.ctx = setupCanvas(this.canvas);
            this.width = this.canvas.getBoundingClientRect().width;
            this.height = this.canvas.getBoundingClientRect().height;
            this.ox = this.width * 0.4; // Fixed eye offset
            this.oy = this.height / 2;
            this.draw();
        });
    }

    draw() {
        super.calculate();
        const ctx = this.ctx;
        const w = this.width;
        const h = this.height;
        ctx.clearRect(0,0,w,h);
        ctx.save();
        ctx.translate(this.ox, this.oy);

        // Retina
        ctx.strokeStyle = '#d32f2f'; ctx.lineWidth = 4;
        ctx.beginPath(); ctx.moveTo(this.retinaX, -100); ctx.lineTo(this.retinaX, 100); ctx.stroke();
        ctx.fillStyle = '#d32f2f'; ctx.fillText("Retina", this.retinaX - 20, -110);

        // Lens Shape
        const thickness = (150 - this.f) / 3; 
        ctx.beginPath(); ctx.fillStyle = '#e3f2fd'; ctx.strokeStyle = '#1565c0'; ctx.lineWidth = 2;
        ctx.ellipse(0, 0, thickness, 80, 0, 0, Math.PI*2); ctx.fill(); ctx.stroke();

        this.drawArrow(ctx, this.u, -this.h_o, '#2e7d32', 'Object');

        // Rays
        const vX = this.v;
        const vY = -this.h_i;
        ctx.strokeStyle = '#f57f17';
        
        ctx.beginPath(); ctx.moveTo(this.u, -this.h_o); ctx.lineTo(0, -this.h_o); ctx.lineTo(vX, vY); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(this.u, -this.h_o); ctx.lineTo(vX, vY); ctx.stroke();

        if (vX > 0 && vX < 600) this.drawArrow(ctx, vX, vY, 'rgba(0,0,0,0.3)', 'I');
        ctx.restore();

        // Focus Check
        const status = document.getElementById('eye-status');
        const diff = Math.abs(this.v - this.retinaX);
        if(diff < 5) { status.textContent = "Status: PERFECT FOCUS"; status.style.color = "#2e7d32"; } 
        else if (diff < 20) { status.textContent = "Status: Acceptable"; status.style.color = "#f9a825"; } 
        else { status.textContent = "Status: BLURRED"; status.style.color = "#c62828"; }
    }
}

/**
 * TELESCOPE SYSTEM
 */
class TelescopeSystem {
    constructor(canvasId) {
        this.canvas = document.getElementById(canvasId);
        this.ctx = setupCanvas(this.canvas);
        
        this.fo = 200; // Objective focal length
        this.fe = 50;  // Eyepiece focal length
        
        // Setup
        this.width = this.canvas.getBoundingClientRect().width;
        this.height = this.canvas.getBoundingClientRect().height;
        this.oy = this.height / 2;
        this.ox = 50; 
        
        this.attachResizeListener();
    }
    
    attachResizeListener() {
        window.addEventListener('resize', () => {
            this.ctx = setupCanvas(this.canvas);
            this.width = this.canvas.getBoundingClientRect().width;
            this.height = this.canvas.getBoundingClientRect().height;
            this.oy = this.height / 2;
            this.draw();
        });
    }
    
    draw() {
        const ctx = this.ctx;
        const w = this.width;
        const h = this.height;
        ctx.clearRect(0,0,w,h);
        ctx.save();
        ctx.translate(0, this.oy);
        
        // Draw Optical Axis
        ctx.strokeStyle = '#cfd8dc';
        ctx.lineWidth = 1;
        ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(w,0); ctx.stroke();
        
        // 1. OBJECTIVE LENS
        const lens1_x = 100;
        this.drawLens(ctx, lens1_x, 100, '#1565c0');
        ctx.fillStyle = '#1565c0'; ctx.fillText("Objective", lens1_x - 20, -110);
        
        // 2. EYEPIECE LENS
        const lens2_x = lens1_x + this.fo + this.fe;
        this.drawLens(ctx, lens2_x, 60, '#2e7d32');
        ctx.fillStyle = '#2e7d32'; ctx.fillText("Eyepiece", lens2_x - 20, -70);
        
        // RAYS
        const alpha = 0.05; 
        const rayY = 40;
        
        ctx.strokeStyle = '#ff6f00';
        ctx.lineWidth = 1.5;
        
        // Top Ray
        ctx.beginPath();
        ctx.moveTo(0, rayY); 
        ctx.lineTo(lens1_x, rayY); 
        const focusX = lens1_x + this.fo;
        const imageH = this.fo * Math.tan(alpha); 
        ctx.lineTo(focusX, imageH); 
        
        const beta = Math.atan(imageH / this.fe);
        ctx.lineTo(w, imageH - (w - focusX)*Math.tan(beta)); 
        ctx.stroke();
        
        // Bottom Ray
        ctx.beginPath();
        ctx.moveTo(0, -rayY);
        ctx.lineTo(lens1_x, -rayY);
        ctx.lineTo(focusX, imageH); 
        ctx.lineTo(w, imageH - (w - focusX)*Math.tan(beta));
        ctx.stroke();
        
        // Intermediate Image
        this.drawArrow(ctx, focusX, imageH, '#c62828');
        
        ctx.restore();
    }
    
    drawLens(ctx, x, h, color) {
        ctx.beginPath();
        ctx.ellipse(x, 0, 6, h, 0, 0, Math.PI*2);
        ctx.fillStyle = color;
        ctx.globalAlpha = 0.3;
        ctx.fill();
        ctx.globalAlpha = 1.0;
        ctx.strokeStyle = color;
        ctx.stroke();
    }
    
    drawArrow(ctx, x, h, color) {
        ctx.beginPath();
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.moveTo(x, 0); ctx.lineTo(x, h);
        ctx.stroke();
        // Head
        ctx.beginPath();
        ctx.moveTo(x, h); ctx.lineTo(x-3, h-3); ctx.lineTo(x+3, h-3);
        ctx.fillStyle = color; ctx.fill();
    }
}


// --- INITIALIZATION ---
const graph = new GraphSystem();

// Pinhole (Abstract)
const pinholeLab = new OpticsSystem('pinhole-canvas', 'pinhole');
const p_u = document.getElementById('p-u-input');
const p_v = document.getElementById('p-v-input');

function updatePinhole() {
    pinholeLab.u = parseFloat(p_u.value);
    pinholeLab.v = parseFloat(p_v.value);
    pinholeLab.calculate();
    pinholeLab.draw();
    document.getElementById('p-u-val').textContent = pinholeLab.u;
    document.getElementById('p-v-val').textContent = pinholeLab.v;
    document.getElementById('p-calc-res').innerHTML = `Magnification = ${Math.abs(pinholeLab.m).toFixed(2)}x<br>Img Height = ${pinholeLab.h_i.toFixed(1)}`;
}
p_u.addEventListener('input', updatePinhole);
p_v.addEventListener('input', updatePinhole);
updatePinhole();

// Camera Obscura (Ashoka Tree)
const obscuraLab = new CameraObscuraSystem('obscura-canvas');
const o_d1 = document.getElementById('o-d1-input');
const o_d2 = document.getElementById('o-d2-input');
function updateObscura() {
    obscuraLab.d1 = parseFloat(o_d1.value);
    obscuraLab.d2 = parseFloat(o_d2.value);
    obscuraLab.draw();
    document.getElementById('o-d1-val').textContent = obscuraLab.d1;
    document.getElementById('o-d2-val').textContent = obscuraLab.d2;
    const m = obscuraLab.d2 / obscuraLab.d1;
    document.getElementById('o-calc-res').innerHTML = `Scale: ${m.toFixed(2)}x`;
}
o_d1.addEventListener('input', updateObscura);
o_d2.addEventListener('input', updateObscura);
updateObscura();

// Mirror
const mirrorLab = new OpticsSystem('mirror-canvas', 'mirror');
const m_u = document.getElementById('m-u-input');
const m_f = document.getElementById('m-f-input');
function updateMirror() {
    mirrorLab.u = parseFloat(m_u.value);
    mirrorLab.f = parseFloat(m_f.value);
    mirrorLab.calculate();
    mirrorLab.draw();
    document.getElementById('m-u-val').textContent = mirrorLab.u;
    document.getElementById('m-f-val').textContent = mirrorLab.f;
    document.getElementById('m-calc-res').innerHTML = `v = ${Math.round(mirrorLab.v)}<br>m = ${mirrorLab.m.toFixed(2)}`;
    document.getElementById('m-calc-props').innerHTML = `${mirrorLab.v < 0 ? 'Real' : 'Virtual'}, ${Math.abs(mirrorLab.m)>1?'Magnified':'Diminished'}`;
    graph.draw(mirrorLab.u, mirrorLab.v, mirrorLab.f);
}
m_u.addEventListener('input', updateMirror);
m_f.addEventListener('input', updateMirror);
updateMirror();

// Lens
const lensLab = new OpticsSystem('lens-canvas', 'lens');
const l_u = document.getElementById('l-u-input');
const l_f = document.getElementById('l-f-input');
function updateLens() {
    lensLab.u = parseFloat(l_u.value);
    lensLab.f = parseFloat(l_f.value);
    lensLab.calculate();
    lensLab.draw();
    document.getElementById('l-u-val').textContent = lensLab.u;
    document.getElementById('l-f-val').textContent = lensLab.f;
    document.getElementById('l-calc-res').innerHTML = `v = ${Math.round(lensLab.v)}<br>m = ${lensLab.m.toFixed(2)}`;
    document.getElementById('l-calc-props').innerHTML = `${lensLab.v > 0 ? 'Real' : 'Virtual'}, ${lensLab.m < 0 ? 'Inverted' : 'Erect'}`;
}
l_u.addEventListener('input', updateLens);
l_f.addEventListener('input', updateLens);
updateLens();

// Eye
const eyeLab = new EyeSystem('eye-canvas');
const e_u = document.getElementById('eye-u-input');
const e_f = document.getElementById('eye-f-input');
function updateEye() {
    eyeLab.u = parseFloat(e_u.value);
    eyeLab.f = parseFloat(e_f.value);
    document.getElementById('eye-f-val').textContent = eyeLab.f;
    eyeLab.draw();
}
e_u.addEventListener('input', updateEye);
e_f.addEventListener('input', updateEye);
updateEye();

// Telescope
const teleLab = new TelescopeSystem('telescope-canvas');
const t_fo = document.getElementById('t-fo-input');
const t_fe = document.getElementById('t-fe-input');
function updateTelescope() {
    teleLab.fo = parseFloat(t_fo.value);
    teleLab.fe = parseFloat(t_fe.value);
    teleLab.draw();
    document.getElementById('t-fo-val').textContent = teleLab.fo;
    document.getElementById('t-fe-val').textContent = teleLab.fe;
    const mag = teleLab.fo / teleLab.fe;
    document.getElementById('t-calc-res').innerHTML = `Angular Magnification M = ${mag.toFixed(1)}x`;
}
t_fo.addEventListener('input', updateTelescope);
t_fe.addEventListener('input', updateTelescope);
updateTelescope();

</script>
</body>
</html>
